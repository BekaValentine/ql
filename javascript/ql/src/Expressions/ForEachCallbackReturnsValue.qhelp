<!DOCTYPE qhelp PUBLIC
  "-//Semmle//qhelp//EN"
  "qhelp.dtd">

<qhelp>
	
	<overview>
		
		
		<!-- What is the English description of the problem to analyze? -->
		<p>
			Problem Structures: The array method `forEach`, which expects a callback that returns no value, is
			called using a callback that returns a value.
		</p>
		
		
		<!-- What is the reason this is a problem that deserves a query? -->
		<p>
			The <code>forEach</code> method on arrays is intended to be used as an alternative
			to for loops, and as such, it behaves like an iterator where the callback is used
			for its side effects only. Any value returned by a callback passed to
			<code>forEach</code> will be ignored.
		</p>
		
		<p>
			Use of such a callback is an indication that the programmer may have meant to use
			some other method, such as <code>map</code>, which makes use of the returned value,
			or use some other language construction. Where side effects are concerned,
			<code>forEach</code> and <code>map</code> are identical, so such confusion is
			understandable. 
		</p>
		
		
		<!-- What are the main concepts and potentially relevant libraries? -->
        <ul>
          <li>
            Methods and Calls: function utils (to be able to reference the method by name,
            independent of how it's called, whether its directly called or called via
            <code>call</code> or <code>apply</code>)
          </li>
          <li>Callbacks: referring expressions / data flow (for indirect reference to callbacks)</li>
          <li>Return Values: function utils / control flow (for finding returns)</li>
        </ul>
        
        
	</overview>
	
	
	
	<!-- When someone finds occurrences of this problem, how can it be fixed? -->
	<recommendation>
		<p>
			Replace the return with a variable assignment, or use a different array method
			that actually uses the callback's returned value.
		</p>
	</recommendation>
	
	
	
	<!-- What are some test case examples? Positive and Negative cases -->
	<example>
		<p>
			The following source code can be used to test the different cases. The Bad Cases
			should be found by the query, while the Good Cases should not.
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/TestCases.js" />
	
	</example>
	
	
	
	<!-- What are some representative examples? Explain them and how they can be fixed. -->
	<example>
		
		
		<p>
			In the following code, the list <code>arr</code> is iterated over using
			<code>forEach</code>, and returns a boolean true whenever it a predicate holds of
			the iterated element, with the intention of acting like quantifier to test if the
			predicate holds of any element.
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/RepresentativeExample0.js" />
		
		<p>
			This doesn't function as described, however. Since <code>forEach</code> ignores its
			callback's return values, all of the true returns are immediately discarded. The
			value assigned to <code>foundAnElement</code> will be <code>undefined</code>,
			because the <code>forEach</code> itself returns nothing at all.
		</p>
		
		<p>
			The developer should instead treat the callback exactly like a for loop body, and
			initialize the flag external to the loop, and only flip it internally: 
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/RepresentativeExample1.js" />
		
		<p>
			This example also reveals other kinds of conceptual errors that may be at work.
			The programmer who would write this sort of thing is also possibly intending for the
			iteration to stop as soon as a satisfying element is found, but <code>forEach</code>
			will continue to look at every element in the list even though it finds one. This is
			true independent of whether or not it contains the return statement.
		</p>
		
		<p>
			In cases like this, it may be instead desirable to use a reducer, either a builtin
			one such as <code>some</code>:
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/RepresentativeExample2.js" />
		
		<p>
			Or to define a custom reducer:
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/RepresentativeExample3.js" />
		
		<p>
			An even deeper conceptual error is using the inner return as an attempt to return
			an enclosing function. For example, consider this variation:
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/RepresentativeExample4.js" />
		
		<p>
			Here, the intention is that the inner <code>return true</code> will cause the whole
			function <code>anySatisfiers</code> to return, as one would expect from the
			corresponding for loop implementation:
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/RepresentativeExample5.js" />
		
		<p>
			However, this is incorrect: the inner <code>return true</code> causes the
			<em>callback</em> to return true, but has no ability to control the return of
			<code>anySatisfiers</code>. Instead, the flag method would be required:
		</p>
		
		<sample src="examples/ForEachCallbackReturnsValue/RepresentativeExample6.js" />
		
		<p>
			Which should be chosen depends on the intended meaning of the code. Some, such as
			the last example, also make it worthwhile to review the language itself, to ensure
			that fundamental concepts such as control flow are better understood.
		</p>
	</example>
	
	
	
	<!-- What are good places to go if people want to read more? -->
	<references>
		<li>DeepScan: <a href="https://deepscan.io/docs/rules/bad-return-in-foreach">BAD_RETURN_IN_FOREACH</a></li>
	</references>
</qhelp>